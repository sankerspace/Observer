\chapter{Experiments and Testing}
\label{chapter:4}
%% NO PERSONAL FORMS us,we,I
%% quotes use like : ``text''
%% after point,doublepoints and commas there must be a BLANK SPACE

% **************************** Define Graphics Path **************************
\ifpdf
    \graphicspath{{Chapter3/Figs/Raster/}{Chapter3/Figs/PDF/}{Chapter3/Figs/}}
\else
    \graphicspath{{Chapter3/Figs/Vector/}{Chapter3/Figs/}}
\fi

This Chapter is a detailed description about the simulations and experiments of the Invariant Observer.
The first section introduce a survey about the test environment and their different configurations.
The second section shows something about the simulations and their conclusions.
The third section is a detailed description about the test cases and experiments,even something about the performance studies which where
discussed in the chapter before. \\



\section{Reasoning and Environment of Experiments}
\label{chapter:4:section:1}
This section should be considered as a description about the questions ``Which result do we gain from these experiments?'' and ``How are the experiments done?''. 

\subsection{Reasoning and Meaning}
\label{chapter:4:section:1:subsection:1}
The Invariant Observer will interact in an environment where at least soft real-time, but rather hard real-time conditions, should be fullfilled.
The first step, to show  correct behaviour of the algorithm and the resulting VHDL Implementation, are simulations. But it should be mentioned that no 
clear assertions can be made about correct timings. This question relies on the part of experiments. How the simulations and experiments were done, and which insights
they produced, will be discussed in the next subsection.
To present a first proof about correct principle of the Invariant Observer it was necessary to synthesize the VHDL Implementation to get a prototype.
A FPGA was the best solution, besides other possibilities like ASIC's or a Microcontroller. An ASIC (Application-specific integrated circuit) is the most performant solution, but
that solution is hardwired and any change of the design is very expensive. But it could be considered as the final product implementation.
A Microcontroller would never reach the performance of a FPGA and FPGA's are more cost effective and nearly performant like hardwired solutions. 
Any change of the design can be easily downloaded on a FPGA Board, so it seems logical to use FPGA's as protoyping platform.
One important aspect of the experiments was to show the timings of the design. 
for example to show the maximum performance on a FPGA board like the DE2-115, which was used for the expriments, as already mentioned.
But other FPGA's with stronger abilities could reach better performance goals. In \cite{RTFMBJ13} several FPGA models were used to show that aspect.      
A further aspect was to show the ability of handling any propositional formula $\phi$, which is composed of several possible input signals.
The evaluation of $\phi$ takes time, maybe several clock cycles. That circumstance was not exactly tested, but a different approach was
tried to show the same way. A more exact test could be done if this work will be continued.
The next subsection will explain the actual investigations of the experiments in great detail.  
\subsection{Build-up of Experiments}
\label{chapter:4:section:1:subsection:2}
At first some facts about the Invariant Observer will be repeated, to give a better understanding about the tests that were made.
The Invariant Observer consist of several Observer Stages. Every Observer Stage hast to wait, at least the time needed to evalaute a proposition $\phi$, until
th evaluation finished. To cover every clock cycle $e^n$, where a finished computation of a proposition $W(\phi)$ will be evaluated, we need least as many Observer Stages, as
the computation (m clock cycles) needs. To remind, the observer stages are not responsible for the computation of the propositions(like in \cite{RTFMBJ13} ),
but for the final evaluation of the status of the computation.
So it seems logical to create a signal $\phi$ which gives, at every clock cycle, a pseudo evaluation of an proposition $\phi$. 
After that it was easy to show the correct beahviour of the Invariant Observer. 
For example we have m=3 Observer (means theoretical that the evaluation needs 3 clock cycles), and want to show the invariance of signal $\phi$, actually the finished computation $W(\phi)$,
with $\tau = 10$. That 3 Observer Stages shows whether the $W(\phi)$ was invariant 10 clock cycles before and the current clock cycle.
The experiments have been exercised with a plain implementation of a signal $W(\phi)$ and with a more complex implementation of $W(\phi)$, which gives a stronger argument of the correct behaviour.
More about that in the simulation section and experiment section.
That two versions of simulating the input signal of the observer are justified with the fact, that the Quartus synthesis tool could create distinct implementations of the Observer Design, because it must
match the correct timing behaviours. This will be discussed in the experiment section       
The experiments consists of a plain Observer Stage with different configurations with the plain input and the complex input. The same with several Observer Stages.
The next section gives us an insight about the simulations.
%
%A) Reason for tests (behaviour,design improvements,faster design)
%\subsection{}
%B) Test Board , Analyzer ,Versions, Configurations? 
%PF2 -Sampling rate Logic Analyzer

%Top.vhd
%Signalgenerator.vhd

%
%% + SOMETHING ABOUT sIGNALGENERATOR



\section{Simulations}
\label{chapter:4:section:2}
To simulate the VHDL Design of the Observer Stages  the simulation tool \textbf{ModelSim (Version 10.1d)} from \textbf{MentorGraphics} was used.  
A testbench created for simulations in Modelsim gives a good overview about the intended behaviour of the implemented algorithm and it is usefull for debugging and error detection. 
At the beginning, only one Observer Stage was simulated, because it demonstrates the simplest case. 
After error corrections and succesfull simulation of one Observer Stage, which behaves 
like an native Invariance Observer, simulations were proceed with more Observer Stages.\\
 
In Figure~\ref{fig:simulation:five} there is illustrated a simulation with m=5 Observer, where every observer stage monitors the yellow-colored input signal $\phi$ for Invariance $\tau=3$. 
The most left column shows the names of the illustrated signals. For every Observer (OBS1 to OBS5), signals cycle, $count_p$ and their outputs (add1 to add5) are shown to overlook their 
behaviour on input signal $phi\_s$ (=$\phi$). Signals cycle and $count_p$ are already descibed in Chapter~\ref{chapter:3}, so there is nothing additional. 
Signals add1 to add5 are the outputs of the different Observer Stages, which are linked together in a binary add operation. 
The result of that operation is illustrated as the red-colored signal $output_s$ which shows the final result of the Invariance Observer. \\
Signal $phi\_s$ is generated by a complex signalgenerator to get a nearly universal test signal. The green-colored signal at the top indicates the system clock which drives the signalgenerator 
with his output $phi\_s$ and all the observer stages at the same time. But the signalgenerator is driven on the rising edge, the Oberver Stages on falling edge. 
This fact is important to understand one further explanations of the simulation. 
The most important thing that is shown in that illustration is that the observer stages activate the final $output\_s$ exactly $tau + 1$  clock cycles after signal phi\_s still holds his active state. 
This case is  indicated between the two big vertical lines. 
This shows that the Invariance Observer monitored an Invariance Situation of signal $phi\_s$, according to the behaviour described in Chapter~\ref{chapter:2}. 
The Invariance Situation continues three clock cycles until signal phi\_s goes into a non active state. \\
As mentioned, signal phi\_s changes his states on every rising edge, whereas a Observer Stage checks the state of signal phi\_s on every falling edge. 
This explains the delayed reaction of the Observer Stages on changes of the input signal. This handicap could be enhanced by driving the Observers clock a multiple faster. 
The signalgenerator is designed to increase the invariance of his active state continuously, so it was reasonable to see how the final red-colored output works. 
To make it clear, signal phi\_s which is created by the signalgenerator only delivers a pseudo input for the Observer Stages which can be understood like as, at every clock cycle, a computation of 
$W(\phi)$ is finished and the result of that computation is illustrated as true (active state) or false (low state). 
This means, that the number of Observer Stages in Figure~\ref{fig:observerstages} has no intended meaning. 
There could be also only one Observer Stage or more than five, the simulation would behaves he same. \\  
Finally, it should be discussed how the Observer Stages are initialised. The fourth signal from the top enable\_s activates the first Observer Stage which is located at the beginning of the 
Observer Cascade. This principle is shown in Figure~\ref{fig:observerstages}. 
After one clock cycle the following Observer Stage will be activated by signal en\_1, and after one clock cycle again signal en\_2 activates the next Observer Stage and so on. 
In Figure~\ref{fig:simulation:five} this bahaviour is illustrated at the beginning by signal enable\_s, signals en\_1 till en\_4 and the last output in the cascade by signal next\_obs. \\

A further more detailed illustration is shown in Appendix~\ref{appendix:2} with m=10 Observer. 
Simulations with different configurations were made, with different numbers of Observer Stages and different Invariance Qualifications. 
Automated Testing was necessary to have a stronger error check in case of changes in the design. 
Assertions as part of th VHDL language were inserted in to the Code to have a possibility to check if the behaviour of the Observer Stages is still the same. 
Modelsim gives also the possibilty of scripting,  which is very helpful when a lot of simulation parameters have to be handled. \\
The last section introduces the experiments, which were exercised after simulations.  


\begin{figure}[]
\centering
%\hspace{3.0cm}
%\vspace{-5cm}
\includegraphics[width=650px,height=300px,angle=-90]{../../pictures/Modelsim/5_Observer_tb_1.png}
%\includegraphics[height]{../../pictures/Modelsim/10_Observer_tb_1.png}
\caption[Modelsim Simulation of 5 Observer]{Illustration of a Simulation with m=5 Observer and Invariance $\tau=3$}
\label{fig:simulation:five}
\end{figure}

\newpage
%C)Simulations
\section{Experiments}
\label{chapter:4:section:3}
This section treats the experiments done for the Invariance Observer Design. The main part of the experiments were dedicated for testing of the behaviour of the
Invariant Observer Stages. Other experiments were justified by the reason to figure out the maximum performance ot these Observer Stages. 
It is decent to presentate only the edge cases of the experiments, which have reasonable arguments, but it is clear that a lot of more test cases where exercised. 
At first it was important that the correct behaviour of the Invariant Observer Stages was tested and demonstrated on the FPGA Board. 
 
The correct behaviour of the Invariant Observer Design, synthesized on a DE2-115 FPGA board, will be shown by following pictures made with the Logic Analyzer (Agilent 16803A). 
The logic analyzer was used to monitor the output pins GPIO(0) to GPIO(34) of the FPGA Board. 
A example of a TOP VHDL file which embeeds the Invariant Observer Design inside a Test Environment is shown 
in Appendix~\ref{appendix:1}. %!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
A lot of TOP files with different configurations where created, but this one example should only show how the experiments work. 
The output of every Observer Stage is connected to a GPIO output pin, and every of these GPIO pins can be measured and displayed on the logic analyzer. 

The pictures shown for up tp 5 Observers show only the ouputs from GPIO(0) to GPIO(14) in the left side of every these pictures. 
For 10 Observers, the examples in Figure~\ref{fig:logicanalyzer:m10:t1:1} and Figure~\ref{fig:logicanalyzer:m10:t1:1} illustrate the output pins from GPIO(0) to GPIO(31). 
For example the first signal GPIO(0) is always the reset\_s signal similar to the arrangement in Figure~\ref{fig:simulation:five} 
The names of the signals in the following picture are also the same like in the simulation, so it should be clear what the signals in the appropriate line means. 

\subsection{Testing the Behaviour}
\label{chapter:4:section:3:subsection:1}
The experiments in this subsection are realized with a signalgenerator which was build individually to simulate a continously increasing invariance signal. 
This is only the case, because we want to see the correct behaviour of the Observer Stages indicated by add0 to addn and final\_output. 
The signalgenerator and the observer stages are driven with the same input clock of 50Mhz, only for demonstrations. 
A indicated $f_{max}$ means the maximum frequency estimation from the Quartus Tool for the whole design according to the Slow 1200mv 85Â°C model, which was described in subsection Chapter~\ref{chapter:3:section:sub:2}. 
But that will be more considered in the next subsection regarding the performance, whereas this section has no significant arguments regarding the performance of the Observer Stages, 
because $f_{max}$ also depends on the inlcuded signalgenerator. 
The pictures in that subsection are very similar to the explanations in Section~\ref{chapter:4:section:2}, so no additional explanation will be added. \\
Every picture contains two clock signals, one for the signalgenerator and one for the Observer Stages, this was introduced only for the possibilty that the frequency of \textbf{CLK\_OBSERVER} 
is a multiple of \textbf{CLK\_Generator}, but that idea was declined because of some irregular behaviours which will be discussed in the Conclusion of that Thesis. 
In principle \textbf{CLK\_Generator} and \textbf{CLK\_OBSERVER} should be the same. 

% Figure~\ref{fig:logicanalyzer:m1:t1}
% Figure~\ref{fig:logicanalyzer:m5:t10}
% Figure~\ref{fig:logicanalyzer:m10:t1:1}
% Figure~\ref{fig:logicanalyzer:m10:t1:2}

The simplest case as the first picture Figure~\ref{fig:logicanalyzer:m1:t1} shows, is one Observer $m = 1$ and $\tau = 1$ .
Like in the simulation explained the vertical lines indicates the start of an Invariance Condition and the start of active signal phi\_s itself.

\begin{figure}[]
\centering
%\hspace{-3.0cm}
%\vspace{-5cm}
\includegraphics[width=300px,height=150px]{../../pictures/Logicanalyzer/Observer_1_Tau_1.png}
\caption[Logicanalyzer m=1,$\tau=1$]{Illustration from the Logic,only one Observer Stage with m=1,$\tau = 1$}
\label{fig:logicanalyzer:m1:t1}
\end{figure}

\begin{itemize}
 \item $\tau = 1 \;with\; f_{max}=91,41\;Mhz$ (shown in Figure~\ref{fig:logicanalyzer:m1:t1})
 \item $\tau = 10 \;with\; f_{max}=87,61\;Mhz$ 
\end{itemize}

\begin{figure}[]
\centering
%\hspace{-3.0cm}
%\vspace{-5cm}
\includegraphics[width=300px,height=150px]{../../pictures/Logicanalyzer/5_Observer_Tau_10.png}
\caption[Logicanalyzer m=5,$\tau = 10$]{Illustration from the Logic analyzer which shows the m=5,$\tau = 10$}
\label{fig:logicanalyzer:m5:t10}
\end{figure}

Figure~\ref{fig:logicanalyzer:m5:t10} shows 5 Observer (m=5) with observing Invariance of 10 clock cycles\\
Signal \textbf{final\_OUTPUT} is the binary conjunction from add0 to add4. 
The vertical lines indicates the beginning of the observation by the Observer Stages (phi\_s in active state) and 
the Invariance Condition $\tau = 10$ fullfilled at the right vertical line. If every falling edge of signal \textbf{CLK\_OBSERVER} is counted
between both vertical lines, it should be equal to $\tau + 1 = 11$. Same principle should hold for further pictures. 


Figure~\ref{fig:logicanalyzer:m10:t1:1} and Figure~\ref{fig:logicanalyzer:m10:t1:2} show the same experiment (illustration from logic analyzer sperated in two pictures) 
with 10 Observer (m=10) which are observing Invariance of $\tau = 1$ on signal phi\_s. 
Figure~\ref{fig:logicanalyzer:m10:t1:2} illustrates the same behaviour like the pictures before. \\
Figure~\ref{fig:logicanalyzer:m10:t1:2} also shows how the Observer Stages are switched on, one by one. 
Signal \textbf{enable\_start} shows the start of that start-up sequence, important to see the behaviour as part of the Algorithm~\ref{alg:observerstage} that 
every Observer Stage turns on the next following Observer Stage after one clock cycle as illustrated by Figure~\ref{fig:observerstages}. 
\begin{figure}[]
\centering
%\hspace{-3.0cm}
%\vspace{-5cm}
\includegraphics[width=300px,height=150px]{../../pictures/Logicanalyzer/10_Observer_Tau_1_2.png}
\caption[Logicanalyzer m=10,$\tau = 1$]{Illustration from the Logic analyzer which shows the m=1,$\tau = 1$}
\label{fig:logicanalyzer:m10:t1:1}
\end{figure}


\begin{figure}[]
\centering
%\hspace{-3.0cm}
%\vspace{-5cm}
\includegraphics[width=300px,height=150px]{../../pictures/Logicanalyzer/10_Observer_Tau_1_1.png}
\caption[Logicanalyzer m=10,$\tau = 1$]{Illustration from the Logic analyzer which shows the m=10,$\tau = 1$}
\label{fig:logicanalyzer:m10:t1:2}
\end{figure}

The next subsection shows a chain of experiments which could be argued as ``What is the maximum possible clock frequency that can drive the Observer Stages?''

\subsection{Maximum Performance}
\label{chapter:4:section:3:subsection:2}
This subsection discuss the maximum possible performance of the Observer Stage Design under involvement of the limitation by the DE2-115 FPGA Board.





