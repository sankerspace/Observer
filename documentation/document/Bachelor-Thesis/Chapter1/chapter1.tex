%*****************************************************************************************
%*********************************** First Chapter ***************************************
%*****************************************************************************************

%% Title with Math \texorpdfstring{$\sigma$}{[sigma]} => Title with Math Ïƒ

%%A {\em \LaTeX{} class file}\index{\LaTeX{} class file@LaTeX class file} is a file, which holds style information for a particular \LaTeX{}.

%%\begin{eqnarray}
%%CIF: \hspace*{5mm}F_0^j(a) &=& \frac{1}{2\pi \iota} \oint_{\gamma} \frac{F_0^j(z)}{z - a} dz
%%\end{eqnarray}

% reference to a chapter: (see Section~\ref{section1.3})

%formula:	$E^2 = (m_0c^2)^2 + (pc)^2$


\chapter{Introduction}  %Title of the First Chapter

\ifpdf
    \graphicspath{{Chapter1/Figs/Raster/}{Chapter1/Figs/PDF/}{Chapter1/Figs/}}
\else
    \graphicspath{{Chapter1/Figs/Vector/}{Chapter1/Figs/}}
\fi


%********************************** %First Section  **************************************
\section{Overview of the Bachelor Thesis } %Section - 1.1 

In embedded real time systems it is necessary to make efforts to verify a system design.
A system design can be formalized by a mathematical specification for a dynamic system model.
One approach to system design verification is the deduction, that shows that the design implies the requirements. 

In critical Real Time Systems (RTS) timing constraints have to be considered in the requirement engineering.
Such Real Time Systems are modelled by states changing over time.
Time constraints can be formulated as constraints on the duration of critical states. 
A real time logic should be able to specify that real time constraints. Generally it seems that two main classes
of real time logic are present, explicit or implicit temporal logic.\cite{210306} 

Explicit temporal logic is an expression of a time variable. The time variable can be the representation of a time interval or a variable in temporal logic. 
Implicit temporal logic (for example MTL - Metric Temporal Logic) is using temporal operators that constrain the extend of a state.
It is based on interval temporal logic and the duration concept.
Implicit temporal logic can be very useful to express before/after relations between concurrent actions.
For further details \cite{210306} can be a good source of information.
In runtime verification a monitor evaluates executions of a \textbf{System under Test (SUT)} \cite{RTFMBJ13}. 
The evaluation is formalised from a formal specification described in temporal logic.\newpage
For ultra critical systems it is important to meet four major requirements:
\begin{enumerate}
 \item Functionality : cannot change target's behaviour
 \item Certifiability: must avoid re-certification
 \item Timing :	  must not interfere with the target's timing
 \item Swap :     must not exhaust size, weight and power tolerance
\end{enumerate}

A \textbf{Runtime Verification Unit (RVU)} is a verification monitor that meets that four major requirements.
As part of this requirements, the RVU must be separated from SUT.
In fact it is a synthesized hardware that monitors the execution of a SUT.\newline
The topic of my thesis ``Hardware implementation of an Invariant Observer'' can also be considered as a RVU, 
it evaluates the execution of a SUT and checks it for invariance conditions.
My observer is an alternative  implementation of the invariant observer INVARIANT-SYMBOL published in \cite{RTFMBJ13},
that bypass the problem of resource limitation and make use of the significant advantages of a high parallel
\textbf{Field Programmable Gate Array(FPGA)} hardware implementation.
The most important difference is that my observer is not bounded to a specific $\tau$, but the observer in \cite{RTFMBJ13}
are bounded.This feature will be explained in the next section.

In the publication ``\textbf{Real-Time Runtime Verification on Chip} '' \cite{RTFMBJ13} the concept of a RVU and 
the principles of that Verification Framework are described in great detail.\newline\newline
A survey about the functionality of the invariant observer in the following sections.




% \nomenclature[z-cif]{$CIF$}{Cauchy's Integral Formula}                                % first letter Z is for Acronyms 
% \nomenclature[a-F]{$F$}{complex function}                                                   % first letter A is for Roman symbols
% \nomenclature[g-p]{$\pi$}{ $\simeq 3.14\ldots$}                                             % first letter G is for Greek Symbols
% \nomenclature[g-i]{$\iota$}{unit imaginary number $\sqrt{-1}$}                      % first letter G is for Greek Symbols
% \nomenclature[g-g]{$\gamma$}{a simply closed curve on a complex plane}  % first letter G is for Greek Symbols
% \nomenclature[x-i]{$\oint_\gamma$}{integration around a curve $\gamma$} % first letter X is for Other Symbols
% \nomenclature[r-j]{$j$}{superscript index}                                                       % first letter R is for superscripts
% \nomenclature[s-0]{$0$}{subscript index}                                                        % first letter S is for subscripts




%********************************** %Second Section  *************************************
\newpage
\section{The Invariant Observer } %Section - 1.2
This section is a survey about the invariant observer and how it works.
More details about the observers algorithm are presented in the next chapter. \newline
The Invariant Observer acts like the temporal (invariant previously) operator $\boxbox_\tau \phi$
of the Metric Temporal Logic (MTL) and is of course restricted on the past time (ptMTL).
The temporal operator takes an input $\phi$ , the calculation of a propositional
formula, and evaluates if $\phi$ holds for the past $\tau$ execution times , including
the current execution time in a discrete time setting.
For example the logical consequence $e^n \models \boxbox_3 \phi$ expresses that
the current execution $e^n$ (with n as the discrete execution time, n$\in\mathbb{N}$)
is true iff (if and only if) the evaluation of $\phi$ is true now and was also true the last 
$\tau=3$ execution times. In fact the $\boxbox_\tau \phi$ is a specialization of the 
$\boxdot_{[0,\tau]}\phi$ ptMTL operator which inidcates the range of the invariance qualification.\newline
Figure~\ref{fig:inv_example} and Figure~\ref{fig:inv_example_2} show an example for such a temporal operator.
 \newline
%\newpage
\begin{figure}[h] 
\centering 
\begin{tikztimingtable}[scale=1.75,timing/counter/new={char=Q,reset char=R}]
  $n$ & 25{Q} \\
  $e^n \models \phi$ & 1{L}1H2L2H3L3H4L4HL4H\\
  $e^n \models \boxbox_\tau \phi$ & 19{L}1{H}4{L}1{H} \\
  \extracode
  \begin{pgfonlayer}{background}
  \end{pgfonlayer}
  \begin{background}[shift={(0.1,0)},dashed,help lines]
   \vertlines{}
  \end{background}
\end{tikztimingtable}
\caption[Invariant Observer with $\tau=3$]{Example for Invariant Operator  $\boxbox_\tau \phi$  with  $\tau$=3 }
\label{fig:inv_example}
\end{figure}
\newline
\begin{figure}[h] 
\centering 
\begin{tikztimingtable}[scale=1.75,timing/counter/new={char=Q,reset char=R}]
  $n$ & 25{Q} \\
  $e^n \models \phi$ & 1{L}1H2L2H3L3H4L4HL4H\\
  $e^n \models \boxbox_\tau \phi$ & 11{L}1{H}7{L}1{H}4{L}1{H} \\
  \extracode
  \begin{pgfonlayer}{background}
  \end{pgfonlayer}
  \begin{background}[shift={(0.1,0)},dashed,help lines]
   \vertlines{}
  \end{background}
\end{tikztimingtable}
\caption[Invariant Observer with $\tau=2$]{Example for Invariant Operator  $\boxbox_\tau \phi$  with  $\tau$=2 }
\label{fig:inv_example_2}
\end{figure}

My approach of the invariant observer is based on some certain requirements.
The following subsection will discuss these requirements.
 %******************* Subsection 1*******************
\subsection{First Requirement}
To introduce the first requirement we begin with the discussion of the  problem that the calculation
of a atomic propositional formula $\phi$ could take several clock cycles (execution times).
This means that a observer has to wait until the calculation of the proposition is finished.
In \cite{RTFMBJ13} the observer needs to guarantee that it finishes evaluation of atomic propositions
within a tight time bound.
In our case ,if we start calculation of a propositional formula $\phi$ at every clock cycle and the 
calculation itself needs $y$ clock cycles , than we need $y$ observer stages to cover at every clock cycle
a finished calculation. These observer stages are part of the whole observer.
After $y$ clock cycles , at every following clock cycle a calculation of $\phi$ will be available. At least
one observer stage is ready to evaluate a calculation $\phi$ at any time.
In other words, we are implementing temporal pipeline stages that represents components of the
invariant operator and these components together are evaluating the invariance qualification of the proposition $\phi$.
We don't have one observer, in fact the observer is composed from several observer stages.
As a matter of fact, different many clock cycles for the calculation of $\phi$ are possible.
Propositional formulas can be composed from several other complex propositional subformulas.
In some cases a subformula is waiting for the resolution of an another subformula.
In \cite{RTFMBJ13}  this balance is achieved with the restriction of the atomic proposition class
by the abstract domain of logahedron.

%********************************** % Third Section  *************************************
\section{Where does it come from?}  %Section - 1.3 
\label{section1.3}

